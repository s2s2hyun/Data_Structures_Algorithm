function InsertionSort(arr) {
    // 1. 정렬할 배열을 받을 매개변수  arr 를 만듭니다.
    // 이제 정렬되지 않은 영역의 첫번째 원소부터 시작해서
    // 마지막 원소까지 순회하기 위한 for문을 넣어주겠습니다.
    for (let i = 1; i < arr.length; i++) {
        // 2. i 가 1부터 시작하는 이유는 0번째 인덱스 , 즉 첫번째 원소는 이미 정렬되어 있다고 가정하기 때문입니다.
        // i 인덱스에 해당하는 원소는 정렬되지 않은 첫번째 데이터입니다.
        // 따라서 해당 데이터를 변수에 따로 저장해주겠습니다.
        let insertingData = arr[i];
        // 3.이제 2번째  for문을 만들어 줘야합니다
        // 정렬된 영역의 맨 뒤부터 첫 번째 원소까지 역순으로 순회하면서 정렬될 원소의 삽입 위치를 찾는 부분입니다.
        // 삽입 위치를 기억해주기 위해 j라는 변수를 먼저 선언해주겠습니다.
        let j;
        // 정렬된 영역의 마지막 원소는 정렬되지 않은 영역의 첫 번째 원소의 한 칸 앞 입니다.
        // 정렬되지 않은 영역의 첫번째 원소는 i이므로 ,
        // j 에는 i -1 로 초기화를 해 정렬된 영역의 맨 뒤로 설정해주겠습니다.
        // 이렇게 되면 j는 4로 6을 가르키게 됩니다.
        // 정렬된 영역의 마지막 인덱스부터 첫 번째 인덱스까지 역순으로 순회 해줍니다.

        for (j = i - 1; j >= 0; j--) {
            // 4. 이제 정렬된 영역의 마지막 원소에서 역순으로 순회하면서 삽입할 원소와 비교해주는 코드를 넣어줍니다.
            // 현재 순회하는 인덱스의 원소가 삽입할 원소보다 크다면 오른쪽 인덱스에 덮어 씌워주겠습니다.
            // 만약에 해당 인덱스의 원소가 삽입할 원소보다 크다면  해당 인덱스의 원소를 오른쪽으로 덮어써주고
            // 그렇지 않다면 삽입할 원소보다 작은 원소의 자리를 찾았으니 for문을 나오게 합니다.
            // 삽입할 원소보다 작은 원소의 인덱스는 j에 기록되어 있습니다.
            if (arr[j] > insertingData) {
                arr[j + 1] = arr[j];
            } else {
                break;
            }
        }
        // 5. 이렇게 안쪽 for문을 마치고 나오면 삽입할 배열의 위치가 정해집니다. 지금은 0번 인덱스(1) 다음,
        // 즉 1번 인덱스에 2를 삽입하면 됩니다.
        // 그럼 j 보다 1큰 위치에 insertingData를 "삽입" 해줍니다.
        arr[j + 1] = insertingData;
        // 6. 이런 식으로 바깥쪽 for문을 모두 순회하면 배열이 정렬됩니다.
    }
}

// 정렬되지않은 배열을 선언해주고
let arr = [4, 1, 5, 3, 6, 2];
// 바로 출력해봅니다

console.log("===== 정렬 전 ====");
console.log(arr);

InsertionSort(arr);
console.log("=== 정렬 후 ====");
console.log(arr);

// console.log() 출력
// ===== 정렬 전 ====
// [ 4, 1, 5, 3, 6, 2 ]
// === 정렬 후 ====
// [ 1, 2, 3, 4, 5, 6 ]
// 잘 동작합니다.
