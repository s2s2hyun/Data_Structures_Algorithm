// 큐 - 개념

// First In First Out (FIFO) 먼저들어간 데이터가 먼저 나오는 규칙이다 .

// 먼저들어간게 나중에 나오는 스택과의 반대의 특성을 가지고 있다.

// 큐는 운영체제에서도 쓰입니다.
// 운영체제가 프로세스의 작업 요청을 들어온 순서대로
// 큐에 넣고 CPU 가 순서대로 꺼내서 처리합니다.
// 이를 운영체제에서는 FIFO 스케쥴링이라고 합니다.

// 큐는 일상생활에서 질서있는 줄을 큐라고 생각하면 쉽다.

// 스택과 마찬가지로 우리는 큐를 연결리스트로 구현할껍니다

// 데이터를 1,2,3,4 를 순서대로 삽입하겠습니다 .

// 삽입은 head 로 , 즉 가장 앞부분으로 했습니다 .
// 이제 1이 가장 나오려면 어디서 부터 제거를 해야할까요 ?
// 가장 뒤에서 부터 데이터를 제거 하게 되면 1이 제거가 됩니다.

// 하지만 여기서 구현을 생각하면 약간의 문제가 생깁니다.

// 우리가 구현한 연결리스트를 이용하면 head 를 이용해
// 첫 번째 위치에 데이터를 삽입하는 것은 간단합니다.

// 우리가 구현한 것은 앞의 노드가 뒤의 노드를 가르키는 단방향 연결리스트 였습니다 . 이런 구조면 데이터를 뒤에서 제거하기 힘듭니다. 왜일까?

// 데이터 삽입에는 어려운것이 없습니다 . head를 이용해서 간단하게 삽입이 쉽다.
//  하지만 데이터 제거는 가장 뒤의 노드를 제거해야하는데
//  가장 뒤의 노드에 접근하기 위에서는 가장 앞(head) 노드부터
// 순서대로 타고 가야 한다는 점입니다.

// O(n)의 성능이 나옵니다 . 성능을 위해서 우리는 tail 이라는 변수를
//  하나 더 만들어 줄겁니다.

// head 는 가장 앞에 노드를 가르키고 tail 은 가장 뒤에 노드를 가르키게 됩니다.
//  이렇게 되면 tail 이용해서 데이터를 O(1) 성능으로 제거할수 있습니다.

// 하지만 tail 변수만 추가한다고 계속 O(1) 의 성능을 지니는건 아닙니다.
// tail 을 이용해서 데이터를 제거할때 tail 이 가리키던 노드는
// 삭제하면 그만이지만 삭제된 이전 노드를 다시 tail로 설정해줘야합니다.
//  하지만 우리가 만든 연결리스트는 다음 노드만 가르키는 단방향 연결리스트
// 이기때문에 tail 로 이전 노드를 참조하는것은 불가능 합니다.

// head 를 이용해서 맨앞의 노드부터 찾는 수밖에 없죠

// 하지만 이 방식은 O(n)의 성능을 가집니다.

// 그래서 우리는 현재 노드가 이전 노드도 가리키게 할수있는
// 이중연결리스트로 수정합니다. 이중 연결리스트로 이전 노드를
// 참조할 수 있다면 tail 변수 하나를 이용해 현재 노드를 제거하고
// tail 이전 노드를 tail 로 새로 할당할 수 있게 됩니다.
