// 재귀  - " 어떠한 것을 정의 할때 자기 자신을 참조하는것 "
// 우리는 함수를 정의 할때 재귀를 선언 하는데
// 이렇게 재귀적으로 정의된 함수를 재귀함수라고 합니다.

// 재귀 함수
// function myFunction(number) {
//     if (number > 10) return;
//     console.log(number);

//     myFunction(number + 1);
// }

// myFunction(1);
// 숫자가 1부터 1111111 까지 출력이 됩니다.
// 우리는 종료하는 코드가 없는데 자동으로 종료했습니다.
// 이는 콜스택이라는 메모리 공간이 가득차서 자동으로 종료된것입니다.
// 콜스택은 아래서 다시 이야기

// 위에 함수는 실제로 써먹을수가 없는 함수입니다.  재귀함수는 탈출 조건, 즉 기저 조건이
// 반드시 필요합니다. 자기 자신을 계속 호출하다가 특정 조건이 나오면 함수를 종료하는 상황을 만들어보겠습니다.

// for (let i = 1; i < 11; i++) {
//     console.log(i);
// }
// 이처럼 1부터 ~10까지 증가하는 반복문을 이와같은 재귀함수식으로 만들어보겠습니다.
// 우리가 원하는 것은 10까지만 출력하는것이지만 이방법으로는 10까지 도착을 해도
// 멈추지 않습니다.
// function myFunction 에 조건을 추가해주겠습니다.
// if 문을 추가하고 Node 를 확인해보니 10까지만 출력이 되었습니다.

// ############# 콜스택
// 콜스택은 함수가 호출되면서 올라가는 메모리 영역으로 스택이라고 부릅니다.
// 다른 메모리 영역도 있지만 지금은 중요하지 않기 때문에 스택만 알아도 충분합니다.
// 콜스택은 스택의 특성처럼 먼저 들어온 데이터가 나중에 나간다 라는 특성을 가지고 있다.
// 함수를 호출하면 이 함수는 콜스택위로 올라가게 됩니다.
// 함수가 종료되면 콜스택에서 함수는 제거됩니다.

// 함수 A와 함수 B를 호출하는 두가지 상황을 예시로 들겠습니다.
// function funcA() {
//     let a = 10;
//     let b = 5;
//     return a + b;
// }

// function funcB() {
//     let a = 10;
//     let b = 5;
//     return a - b;
// }

// funA();
// funB();

// 먼저 A를 호출하면 이 함수는 콜스택에 올라가게 됩니다.
// 그리고 함수 A를 전부 실행합니다. 그리고 함수 A가 종료되면 콜스택에서 제거 되고
// 함수 B가 불려집니다.
// 그러면 함수 B가 콜스택 위로 올라가게 되고 함수 B를 전부 실행합니다 .
// 그리고 함수 B가 종료되면 스택에서 제거 됩니다.
// 두번째 상황은 함수 A에서 B를 호출하는 상황입니다.

// function funcA() {
//     let a = 10;
//     let b = 5;
//     let c = funcB();
//     return a + b + c;

// }

// function funcB() {
//     let a = 10;
//     let b = 5;
//     return a - b;
// }

// 콜스택에서 A함수 위에 B함수 가 올라가게 됩니다.
//  A함수 내에서 B함수가 실행됩니다. B함수의 실행이 끝났으므로 콜스택에서 B함수가 제거 되고
// A함수는 마저 실행되고 A함수가 종료되면 콜스택에서 A함수가 제거 됩니다.
// 이 콜스택은 스택 자료구조를 잘 활용한 대표적인 사례입니다.
// 그럼 함수가 어떻게 실행되는지 간단하게 메모리 관점에서 알아봤는데 재귀함수를 호출할땐 어떻게 될까?

// 이전에 만들었던 재귀함수에서 기저 조건에 10이라는 숫자를 3으로 변경해봅니다.
function myFunction(number) {
    if (number > 3) return;
    console.log(number);

    myFunction(number + 1);
}

myFunction(1);
// 이렇게 재귀함수는 호출할 때 마다 콜스택의 영역을 차지하게 됩니다.
// 우리가 이전에 기저 조건이 없을때 111111까지 출력되고 종료된 이유는
// 바로 이 콜스택이 계속 쌓여서 메모리가 부족해졌기 때문이다.
// 이때문에 for 문으로 해결할 수 있는 작업을 재귀함수로 해결하면
// 더 비효율적인 상황이 많습니다.재귀함수는 for 문을 대신하려고 쓰기보다는
// 더 복잡한 문제를 쉽게 해결하기 위해 사용됩니다.
// 재귀함수를 이용하면 해결하기 힘든 문제를 쉽게 해결하는 상황이 많은데
// 대표적으로 팩토리얼이 있습니다. 팩토리얼을 구현하면서 재귀함수의 강력함을 알아보겠습니다.
